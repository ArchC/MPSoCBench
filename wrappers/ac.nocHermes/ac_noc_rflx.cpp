// Generated at Sat Nov 19 10:08:39 2011. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/local/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/usr/local/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/local/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='5' -D__DEC64_MAX_EXP__='385' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D_FORTIFY_SOURCE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-94)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.4.5"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6142)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='97' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-382)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__SSP__='1' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='4' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/usr/local/share/gccxml-0.9/GCC/4.4" -isystem"/usr/include/c++/4.4" -isystem"/usr/include/c++/4.4/x86_64-linux-gnu" -isystem"/usr/include/c++/4.4/backward" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include" -isystem"/usr/lib/gcc/x86_64-linux-gnu/4.4.5/include-fixed" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/local/share/gccxml-0.9"

Compiler info:
c++ (Ubuntu/Linaro 4.4.4-14ubuntu5) 4.4.5
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "ac_noc.H"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

#include <Reflex/Builder/DictionaryInitializer.h>
namespace {
  ::Reflex::NamespaceBuilder nsb0( dictionary, Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( dictionary, Reflex::Literal("__gnu_cxx") );
  ::Reflex::Type type_52 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("long"));
  ::Reflex::Type type_662 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("void"));
  ::Reflex::Type type_2531 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("bool"));
  ::Reflex::Type type_507 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("ac_noc"));
  ::Reflex::Type type_1980 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("ac_tlm_rsp"));
  ::Reflex::Type type_1521 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("ac_tlm_req"));
  ::Reflex::Type type_176 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("unsigned int"));
  ::Reflex::Type type_69 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("unsigned long"));
  ::Reflex::Type type_3415 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_core::sc_event"));
  ::Reflex::Type type_527 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_dt::sc_uint<32>"));
  ::Reflex::Type type_3245 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_core::sc_module"));
  ::Reflex::Type type_3598 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("ac_noc::addressMap"));
  ::Reflex::Type type_3241 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_core::sc_module_name"));
  ::Reflex::Type type_1994 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("std::list<ac_noc::addressMap>"));
  ::Reflex::Type type_2172 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("std::allocator<ac_noc::addressMap>"));
  ::Reflex::Type type_2108 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("std::_List_node<ac_noc::addressMap>"));
  ::Reflex::Type type_2481 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("std::_List_iterator<ac_noc::addressMap>"));
  ::Reflex::Type type_4 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("tlm::tlm_transport_if<ac_tlm_req,ac_tlm_rsp>"));
  ::Reflex::Type type_3450 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("__gnu_cxx::new_allocator<ac_noc::addressMap>"));
  ::Reflex::Type type_1992 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("std::_List_const_iterator<ac_noc::addressMap>"));
  ::Reflex::Type type_3006 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_core::sc_port<intoRouterIf,1,SC_ONE_OR_MORE_BOUND>"));
  ::Reflex::Type type_3007 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_core::sc_port<outFromRouterIf,1,SC_ONE_OR_MORE_BOUND>"));
  ::Reflex::Type type_2197 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>"));
  ::Reflex::Type type_2286 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("std::reverse_iterator<std::_List_iterator<ac_noc::addressMap> >"));
  ::Reflex::Type type_2997 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_core::sc_export<tlm::tlm_transport_if<ac_tlm_req,ac_tlm_rsp> >"));
  ::Reflex::Type type_2285 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("std::reverse_iterator<std::_List_const_iterator<ac_noc::addressMap> >"));
  ::Reflex::Type type_2086 = ::Reflex::TypeBuilder(dictionary, Reflex::Literal("std::_List_base<ac_noc::addressMap,std::allocator<ac_noc::addressMap> >"));
  ::Reflex::Type type_528 = ::Reflex::TypedefTypeBuilder(dictionary, Reflex::Literal("FLITTYPE"), type_527);
  ::Reflex::Type type_738 = ::Reflex::TypedefTypeBuilder(dictionary, Reflex::Literal("uint32_t"), type_176);
  ::Reflex::Type type_1521c = ::Reflex::ConstBuilder(dictionary, type_1521);
  ::Reflex::Type type_10093 = ::Reflex::ReferenceBuilder(dictionary, type_1521c);
  ::Reflex::Type type_6057 = ::Reflex::ReferenceBuilder(dictionary, type_3598);
  ::Reflex::Type type_3598c = ::Reflex::ConstBuilder(dictionary, type_3598);
  ::Reflex::Type type_6059 = ::Reflex::ReferenceBuilder(dictionary, type_3598c);
  ::Reflex::Type type_6053 = ::Reflex::PointerBuilder(dictionary, type_3598);
  ::Reflex::Type type_6055 = ::Reflex::PointerBuilder(dictionary, type_3598c);
  ::Reflex::Type type_1275 = ::Reflex::TypedefTypeBuilder(dictionary, Reflex::Literal("size_t"), type_69);
  ::Reflex::Type type_1017 = ::Reflex::TypedefTypeBuilder(dictionary, Reflex::Literal("ptrdiff_t"), type_52);
  ::Reflex::Type type_2172c = ::Reflex::ConstBuilder(dictionary, type_2172);
  ::Reflex::Type type_13971 = ::Reflex::ReferenceBuilder(dictionary, type_2172c);
  ::Reflex::Type type_1994c = ::Reflex::ConstBuilder(dictionary, type_1994);
  ::Reflex::Type type_13972 = ::Reflex::ReferenceBuilder(dictionary, type_1994c);
  ::Reflex::Type type_13973 = ::Reflex::ReferenceBuilder(dictionary, type_1994);
  ::Reflex::Type type_14341 = ::Reflex::ReferenceBuilder(dictionary, type_2172);
  ::Reflex::Type type_14367 = ::Reflex::ReferenceBuilder(dictionary, type_2197);
  ::Reflex::Type type_2197c = ::Reflex::ConstBuilder(dictionary, type_2197);
  ::Reflex::Type type_14368 = ::Reflex::ReferenceBuilder(dictionary, type_2197c);
  ::Reflex::Type type_15068 = ::Reflex::ReferenceBuilder(dictionary, type_3450);
  ::Reflex::Type type_3450c = ::Reflex::ConstBuilder(dictionary, type_3450);
  ::Reflex::Type type_15069 = ::Reflex::ReferenceBuilder(dictionary, type_3450c);
  ::Reflex::Type type_662c = ::Reflex::ConstBuilder(dictionary, type_662);
  ::Reflex::Type type_2563 = ::Reflex::PointerBuilder(dictionary, type_662c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __ac_noc
#undef __ac_noc
#endif
class __ac_noc : public ::sc_core::sc_module, public ::tlm::tlm_transport_if<ac_tlm_req,ac_tlm_rsp> {
  public:
  __ac_noc();
  virtual ~__ac_noc() throw();
  virtual ::ac_tlm_rsp transport(ac_tlm_req const&) throw();
  ::sc_core::sc_export<tlm::tlm_transport_if<ac_tlm_req,ac_tlm_rsp> > target_export;
  ::sc_core::sc_port<outFromRouterIf,1,SC_ONE_OR_MORE_BOUND> outPort;
  ::sc_core::sc_port<intoRouterIf,1,SC_ONE_OR_MORE_BOUND> inPort;
  ::sc_core::sc_event doReadEvt;
  ::sc_core::sc_event doWriteEvt;
  bool ready;
  ::FLITTYPE address;
  ::FLITTYPE targetAddress;
  ::FLITTYPE targetData;
  ::uint32_t mem_address;
  ::std::list<ac_noc::addressMap> addresses;
};
#ifdef __ac_noc__addressMap
#undef __ac_noc__addressMap
#endif
class __ac_noc__addressMap {
  public:
  __ac_noc__addressMap();
  ::FLITTYPE nocAddress;
  ::uint32_t startaddress;
  ::uint32_t endaddress;
};
#ifdef __std__list_ac_noc__addressMap_
#undef __std__list_ac_noc__addressMap_
#endif
class __std__list_ac_noc__addressMap_ : protected ::std::_List_base<ac_noc::addressMap,std::allocator<ac_noc::addressMap> > {
  public:
  __std__list_ac_noc__addressMap_();
};
#ifdef __std__allocator_ac_noc__addressMap_
#undef __std__allocator_ac_noc__addressMap_
#endif
class __std__allocator_ac_noc__addressMap_ : public ::__gnu_cxx::new_allocator<ac_noc::addressMap> {
  public:
  __std__allocator_ac_noc__addressMap_();
};
#ifdef __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap_
#undef __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap_
#endif
struct __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap_ {
  public:
  __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap_();
};
#ifdef ____gnu_cxx__new_allocator_ac_noc__addressMap_
#undef ____gnu_cxx__new_allocator_ac_noc__addressMap_
#endif
class ____gnu_cxx__new_allocator_ac_noc__addressMap_ {
  public:
  ____gnu_cxx__new_allocator_ac_noc__addressMap_();
};
}


#endif // __CINT__
namespace {
//------Stub functions for class ac_noc -------------------------------
static void constructor_3599( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ac_noc(*(::sc_core::sc_module_name*)arg[0],
      *(::FLITTYPE*)arg[1],
      *(::uint32_t*)arg[2]);
  else ::new(mem) ::ac_noc(*(::sc_core::sc_module_name*)arg[0],
      *(::FLITTYPE*)arg[1],
      *(::uint32_t*)arg[2]);
}

static  void method_3600( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ac_noc*)o)->addAddress)(*(::FLITTYPE*)arg[0],
    *(::uint32_t*)arg[1],
    *(::uint32_t*)arg[2]);
}

static  void method_3601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (ac_tlm_rsp)((((::ac_noc*)o)->transport)(*(const ::ac_tlm_req*)arg[0]));
  else   (((::ac_noc*)o)->transport)(*(const ::ac_tlm_req*)arg[0]);
}

static void destructor_3608(void*, void * o, const std::vector<void*>&, void *) {
  (((::ac_noc*)o)->::ac_noc::~ac_noc)();
}
static void method_x0( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_core::sc_module")), ::Reflex::BaseOffset< ::ac_noc,::sc_core::sc_module >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_core::sc_object")), ::Reflex::BaseOffset< ::ac_noc,::sc_core::sc_object >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_core::sc_process_host")), ::Reflex::BaseOffset< ::ac_noc,::sc_core::sc_process_host >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(dictionary, Reflex::Literal("tlm::tlm_transport_if<ac_tlm_req,ac_tlm_rsp>")), ::Reflex::BaseOffset< ::ac_noc,::tlm::tlm_transport_if<ac_tlm_req,ac_tlm_rsp> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(dictionary, Reflex::Literal("sc_core::sc_interface")), ::Reflex::BaseOffset< ::ac_noc,::sc_core::sc_interface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ac_noc -------------------------------
void __ac_noc_db_datamem(Reflex::Class*);
void __ac_noc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ac_noc_datamem_bld(&__ac_noc_db_datamem);
Reflex::GenreflexMemberBuilder __ac_noc_funcmem_bld(&__ac_noc_db_funcmem);
void __ac_noc_dict() {
  ::Reflex::ClassBuilder(dictionary, Reflex::Literal("ac_noc"), typeid(::ac_noc), sizeof(::ac_noc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_3245, ::Reflex::BaseOffset< ::ac_noc, ::sc_core::sc_module >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_4, ::Reflex::BaseOffset< ::ac_noc, ::tlm::tlm_transport_if<ac_tlm_req,ac_tlm_rsp> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void, type_3241, type_528, type_738), Reflex::Literal("ac_noc"), constructor_3599, 0, "_name;_address;_mem_address", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("~ac_noc"), destructor_3608, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x0, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ac_noc_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__ac_noc_funcmem_bld);
}

//------Delayed data member builder for class ac_noc -------------------
void __ac_noc_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2997, Reflex::Literal("target_export"), OffsetOf(__shadow__::__ac_noc, target_export), ::Reflex::PUBLIC)
  .AddDataMember(type_3007, Reflex::Literal("outPort"), OffsetOf(__shadow__::__ac_noc, outPort), ::Reflex::PUBLIC)
  .AddDataMember(type_3006, Reflex::Literal("inPort"), OffsetOf(__shadow__::__ac_noc, inPort), ::Reflex::PUBLIC)
  .AddDataMember(type_3415, Reflex::Literal("doReadEvt"), OffsetOf(__shadow__::__ac_noc, doReadEvt), ::Reflex::PRIVATE)
  .AddDataMember(type_3415, Reflex::Literal("doWriteEvt"), OffsetOf(__shadow__::__ac_noc, doWriteEvt), ::Reflex::PRIVATE)
  .AddDataMember(type_2531, Reflex::Literal("ready"), OffsetOf(__shadow__::__ac_noc, ready), ::Reflex::PRIVATE)
  .AddDataMember(type_528, Reflex::Literal("address"), OffsetOf(__shadow__::__ac_noc, address), ::Reflex::PRIVATE)
  .AddDataMember(type_528, Reflex::Literal("targetAddress"), OffsetOf(__shadow__::__ac_noc, targetAddress), ::Reflex::PRIVATE)
  .AddDataMember(type_528, Reflex::Literal("targetData"), OffsetOf(__shadow__::__ac_noc, targetData), ::Reflex::PRIVATE)
  .AddDataMember(type_738, Reflex::Literal("mem_address"), OffsetOf(__shadow__::__ac_noc, mem_address), ::Reflex::PRIVATE)
  .AddDataMember(type_1994, Reflex::Literal("addresses"), OffsetOf(__shadow__::__ac_noc, addresses), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ac_noc -------------------
void __ac_noc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_528, type_738, type_738), Reflex::Literal("addAddress"), method_3600, 0, "nocAddress;start_address;endaddress", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_1980, type_10093), Reflex::Literal("transport"), method_3601, 0, "request", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class addressMap -------------------------------
static void destructor_13062(void*, void * o, const std::vector<void*>&, void *) {
  (((::ac_noc::addressMap*)o)->::ac_noc::addressMap::~addressMap)();
}
static  void operator_13063( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ac_noc::addressMap*)o)->operator=)(*(const ::ac_noc::addressMap*)arg[0]);
  else   (((::ac_noc::addressMap*)o)->operator=)(*(const ::ac_noc::addressMap*)arg[0]);
}

static void constructor_13064( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ac_noc::addressMap(*(const ::ac_noc::addressMap*)arg[0]);
  else ::new(mem) ::ac_noc::addressMap(*(const ::ac_noc::addressMap*)arg[0]);
}

static void constructor_13065( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ac_noc::addressMap();
  else ::new(mem) ::ac_noc::addressMap();
}

static void method_newdel_3598( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::ac_noc::addressMap >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::ac_noc::addressMap >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::ac_noc::addressMap >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::ac_noc::addressMap >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::ac_noc::addressMap >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class addressMap -------------------------------
void __ac_noc__addressMap_db_datamem(Reflex::Class*);
void __ac_noc__addressMap_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ac_noc__addressMap_datamem_bld(&__ac_noc__addressMap_db_datamem);
Reflex::GenreflexMemberBuilder __ac_noc__addressMap_funcmem_bld(&__ac_noc__addressMap_db_funcmem);
void __ac_noc__addressMap_dict() {
  ::Reflex::ClassBuilder(dictionary, Reflex::Literal("ac_noc::addressMap"), typeid(::ac_noc::addressMap), sizeof(::ac_noc::addressMap), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("~addressMap"), destructor_13062, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_6057, type_6059), Reflex::Literal("operator="), operator_13063, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void, type_6059), Reflex::Literal("addressMap"), constructor_13064, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("addressMap"), constructor_13065, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3598, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ac_noc__addressMap_datamem_bld);
}

//------Delayed data member builder for class addressMap -------------------
void __ac_noc__addressMap_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_528, Reflex::Literal("nocAddress"), OffsetOf(__shadow__::__ac_noc__addressMap, nocAddress), ::Reflex::PUBLIC)
  .AddDataMember(type_738, Reflex::Literal("startaddress"), OffsetOf(__shadow__::__ac_noc__addressMap, startaddress), ::Reflex::PUBLIC)
  .AddDataMember(type_738, Reflex::Literal("endaddress"), OffsetOf(__shadow__::__ac_noc__addressMap, endaddress), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class addressMap -------------------
void __ac_noc__addressMap_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class list<ac_noc::addressMap,std::allocator<ac_noc::addressMap> > -------------------------------
static void destructor_6069(void*, void * o, const std::vector<void*>&, void *) {
  (((::std::list<ac_noc::addressMap>*)o)->::std::list<ac_noc::addressMap>::~list)();
}
static void constructor_6071( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<ac_noc::addressMap>();
  else ::new(mem) ::std::list<ac_noc::addressMap>();
}

static void constructor_6072( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<ac_noc::addressMap>(*(const ::std::allocator<ac_noc::addressMap>*)arg[0]);
  else ::new(mem) ::std::list<ac_noc::addressMap>(*(const ::std::allocator<ac_noc::addressMap>*)arg[0]);
}

static void constructor_6073( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<ac_noc::addressMap>(*(::size_t*)arg[0]);
  else ::new(mem) ::std::list<ac_noc::addressMap>(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<ac_noc::addressMap>(*(::size_t*)arg[0],
      *(const ::ac_noc::addressMap*)arg[1]);
  else ::new(mem) ::std::list<ac_noc::addressMap>(*(::size_t*)arg[0],
      *(const ::ac_noc::addressMap*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<ac_noc::addressMap>(*(::size_t*)arg[0],
      *(const ::ac_noc::addressMap*)arg[1],
      *(const ::std::allocator<ac_noc::addressMap>*)arg[2]);
  else ::new(mem) ::std::list<ac_noc::addressMap>(*(::size_t*)arg[0],
      *(const ::ac_noc::addressMap*)arg[1],
      *(const ::std::allocator<ac_noc::addressMap>*)arg[2]);
  }
}

static void constructor_6074( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<ac_noc::addressMap>(*(const ::std::list<ac_noc::addressMap>*)arg[0]);
  else ::new(mem) ::std::list<ac_noc::addressMap>(*(const ::std::list<ac_noc::addressMap>*)arg[0]);
}

static  void operator_6075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::list<ac_noc::addressMap>*)o)->operator=)(*(const ::std::list<ac_noc::addressMap>*)arg[0]);
  else   (((::std::list<ac_noc::addressMap>*)o)->operator=)(*(const ::std::list<ac_noc::addressMap>*)arg[0]);
}

static  void method_6076( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->assign)(*(::size_t*)arg[0],
    *(const ::ac_noc::addressMap*)arg[1]);
}

static  void method_6077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<ac_noc::addressMap>)((((const ::std::list<ac_noc::addressMap>*)o)->get_allocator)());
  else   (((const ::std::list<ac_noc::addressMap>*)o)->get_allocator)();
}

static  void method_6078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<ac_noc::addressMap>)((((::std::list<ac_noc::addressMap>*)o)->begin)());
  else   (((::std::list<ac_noc::addressMap>*)o)->begin)();
}

static  void method_6079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_const_iterator<ac_noc::addressMap>)((((const ::std::list<ac_noc::addressMap>*)o)->begin)());
  else   (((const ::std::list<ac_noc::addressMap>*)o)->begin)();
}

static  void method_6080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<ac_noc::addressMap>)((((::std::list<ac_noc::addressMap>*)o)->end)());
  else   (((::std::list<ac_noc::addressMap>*)o)->end)();
}

static  void method_6081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_const_iterator<ac_noc::addressMap>)((((const ::std::list<ac_noc::addressMap>*)o)->end)());
  else   (((const ::std::list<ac_noc::addressMap>*)o)->end)();
}

static  void method_6086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::list<ac_noc::addressMap>*)o)->empty)());
  else   (((const ::std::list<ac_noc::addressMap>*)o)->empty)();
}

static  void method_6087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::list<ac_noc::addressMap>*)o)->size)());
  else   (((const ::std::list<ac_noc::addressMap>*)o)->size)();
}

static  void method_6088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::list<ac_noc::addressMap>*)o)->max_size)());
  else   (((const ::std::list<ac_noc::addressMap>*)o)->max_size)();
}

static  void method_6089( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::list<ac_noc::addressMap>*)o)->resize)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::list<ac_noc::addressMap>*)o)->resize)(*(::size_t*)arg[0],
      *(::ac_noc::addressMap*)arg[1]);
  }
}

static  void method_6090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::list<ac_noc::addressMap>*)o)->front)();
  else   (((::std::list<ac_noc::addressMap>*)o)->front)();
}

static  void method_6091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::list<ac_noc::addressMap>*)o)->front)();
  else   (((const ::std::list<ac_noc::addressMap>*)o)->front)();
}

static  void method_6092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::list<ac_noc::addressMap>*)o)->back)();
  else   (((::std::list<ac_noc::addressMap>*)o)->back)();
}

static  void method_6093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::list<ac_noc::addressMap>*)o)->back)();
  else   (((const ::std::list<ac_noc::addressMap>*)o)->back)();
}

static  void method_6094( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->push_front)(*(const ::ac_noc::addressMap*)arg[0]);
}

static  void method_6095( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->pop_front)();
}

static  void method_6096( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->push_back)(*(const ::ac_noc::addressMap*)arg[0]);
}

static  void method_6097( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->pop_back)();
}

static  void method_6098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<ac_noc::addressMap>)((((::std::list<ac_noc::addressMap>*)o)->insert)(*(::std::_List_iterator<ac_noc::addressMap>*)arg[0],
    *(const ::ac_noc::addressMap*)arg[1]));
  else   (((::std::list<ac_noc::addressMap>*)o)->insert)(*(::std::_List_iterator<ac_noc::addressMap>*)arg[0],
    *(const ::ac_noc::addressMap*)arg[1]);
}

static  void method_6099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->insert)(*(::std::_List_iterator<ac_noc::addressMap>*)arg[0],
    *(::size_t*)arg[1],
    *(const ::ac_noc::addressMap*)arg[2]);
}

static  void method_6100( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<ac_noc::addressMap>)((((::std::list<ac_noc::addressMap>*)o)->erase)(*(::std::_List_iterator<ac_noc::addressMap>*)arg[0]));
  else   (((::std::list<ac_noc::addressMap>*)o)->erase)(*(::std::_List_iterator<ac_noc::addressMap>*)arg[0]);
}

static  void method_6101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<ac_noc::addressMap>)((((::std::list<ac_noc::addressMap>*)o)->erase)(*(::std::_List_iterator<ac_noc::addressMap>*)arg[0],
    *(::std::_List_iterator<ac_noc::addressMap>*)arg[1]));
  else   (((::std::list<ac_noc::addressMap>*)o)->erase)(*(::std::_List_iterator<ac_noc::addressMap>*)arg[0],
    *(::std::_List_iterator<ac_noc::addressMap>*)arg[1]);
}

static  void method_6102( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->swap)(*(::std::list<ac_noc::addressMap>*)arg[0]);
}

static  void method_6103( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->clear)();
}

static  void method_6104( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->splice)(*(::std::_List_iterator<ac_noc::addressMap>*)arg[0],
    *(::std::list<ac_noc::addressMap>*)arg[1]);
}

static  void method_6105( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->splice)(*(::std::_List_iterator<ac_noc::addressMap>*)arg[0],
    *(::std::list<ac_noc::addressMap>*)arg[1],
    *(::std::_List_iterator<ac_noc::addressMap>*)arg[2]);
}

static  void method_6106( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->splice)(*(::std::_List_iterator<ac_noc::addressMap>*)arg[0],
    *(::std::list<ac_noc::addressMap>*)arg[1],
    *(::std::_List_iterator<ac_noc::addressMap>*)arg[2],
    *(::std::_List_iterator<ac_noc::addressMap>*)arg[3]);
}

static  void method_6107( void*, void* o, const std::vector<void*>& arg, void*)
{
//  (((::std::list<ac_noc::addressMap>*)o)->remove)(*(const ::ac_noc::addressMap*)arg[0]);
}

static  void method_6108( void*, void* o, const std::vector<void*>&, void*)
{
//  (((::std::list<ac_noc::addressMap>*)o)->unique)();
}

static  void method_6109( void*, void* o, const std::vector<void*>& arg, void*)
{
//  (((::std::list<ac_noc::addressMap>*)o)->merge)(*(::std::list<ac_noc::addressMap>*)arg[0]);
}

static  void method_6110( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<ac_noc::addressMap>*)o)->reverse)();
}

static  void method_6111( void*, void* o, const std::vector<void*>&, void*)
{
//  (((::std::list<ac_noc::addressMap>*)o)->sort)();
}

static void method_newdel_1994( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::list<ac_noc::addressMap> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::list<ac_noc::addressMap> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::list<ac_noc::addressMap> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::list<ac_noc::addressMap> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::list<ac_noc::addressMap> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(dictionary, Reflex::Literal("std::_List_base<ac_noc::addressMap,std::allocator<ac_noc::addressMap> >")), ::Reflex::BaseOffset< ::std::list<ac_noc::addressMap>,::std::_List_base<ac_noc::addressMap,std::allocator<ac_noc::addressMap> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::list<ac_noc::addressMap> >::Generate();
  else ::Reflex::Proxy< ::std::list<ac_noc::addressMap> >::Generate();
}

//------Dictionary for class list<ac_noc::addressMap,std::allocator<ac_noc::addressMap> > -------------------------------
void __std__list_ac_noc__addressMap__db_datamem(Reflex::Class*);
void __std__list_ac_noc__addressMap__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__list_ac_noc__addressMap__datamem_bld(&__std__list_ac_noc__addressMap__db_datamem);
Reflex::GenreflexMemberBuilder __std__list_ac_noc__addressMap__funcmem_bld(&__std__list_ac_noc__addressMap__db_funcmem);
void __std__list_ac_noc__addressMap__dict() {
  ::Reflex::ClassBuilder(dictionary, Reflex::Literal("std::list<ac_noc::addressMap>"), typeid(::std::list<ac_noc::addressMap>), sizeof(::std::list<ac_noc::addressMap>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2086, ::Reflex::BaseOffset< ::std::list<ac_noc::addressMap>, ::std::_List_base<ac_noc::addressMap,std::allocator<ac_noc::addressMap> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3598, Reflex::Literal("std::list<ac_noc::addressMap>::_Alloc_value_type"))
  .AddTypedef(type_2086, Reflex::Literal("std::list<ac_noc::addressMap>::_Base"))
  .AddTypedef(type_2172, Reflex::Literal("std::list<ac_noc::addressMap>::_Tp_alloc_type"))
  .AddTypedef(type_3598, Reflex::Literal("std::list<ac_noc::addressMap>::value_type"))
  .AddTypedef(type_6053, Reflex::Literal("std::list<ac_noc::addressMap>::pointer"))
  .AddTypedef(type_6055, Reflex::Literal("std::list<ac_noc::addressMap>::const_pointer"))
  .AddTypedef(type_6057, Reflex::Literal("std::list<ac_noc::addressMap>::reference"))
  .AddTypedef(type_6059, Reflex::Literal("std::list<ac_noc::addressMap>::const_reference"))
  .AddTypedef(type_2481, Reflex::Literal("std::list<ac_noc::addressMap>::iterator"))
  .AddTypedef(type_1992, Reflex::Literal("std::list<ac_noc::addressMap>::const_iterator"))
  .AddTypedef(type_2285, Reflex::Literal("std::list<ac_noc::addressMap>::const_reverse_iterator"))
  .AddTypedef(type_2286, Reflex::Literal("std::list<ac_noc::addressMap>::reverse_iterator"))
  .AddTypedef(type_1275, Reflex::Literal("std::list<ac_noc::addressMap>::size_type"))
  .AddTypedef(type_1017, Reflex::Literal("std::list<ac_noc::addressMap>::difference_type"))
  .AddTypedef(type_2172, Reflex::Literal("std::list<ac_noc::addressMap>::allocator_type"))
  .AddTypedef(type_2108, Reflex::Literal("std::list<ac_noc::addressMap>::_Node"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("~list"), destructor_6069, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("list"), constructor_6071, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void, type_13971), Reflex::Literal("list"), constructor_6072, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void, type_1275, type_6059, type_13971), Reflex::Literal("list"), constructor_6073, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void, type_13972), Reflex::Literal("list"), constructor_6074, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1994, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__list_ac_noc__addressMap__funcmem_bld);
}

//------Delayed data member builder for class list<ac_noc::addressMap,std::allocator<ac_noc::addressMap> > -------------------
void __std__list_ac_noc__addressMap__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class list<ac_noc::addressMap,std::allocator<ac_noc::addressMap> > -------------------
void __std__list_ac_noc__addressMap__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_13973, type_13972), Reflex::Literal("operator="), operator_6075, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_1275, type_6059), Reflex::Literal("assign"), method_6076, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_2172), Reflex::Literal("get_allocator"), method_6077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_2481), Reflex::Literal("begin"), method_6078, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_1992), Reflex::Literal("begin"), method_6079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_2481), Reflex::Literal("end"), method_6080, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_1992), Reflex::Literal("end"), method_6081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_2531), Reflex::Literal("empty"), method_6086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_1275), Reflex::Literal("size"), method_6087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_1275), Reflex::Literal("max_size"), method_6088, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_1275, type_3598), Reflex::Literal("resize"), method_6089, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_6057), Reflex::Literal("front"), method_6090, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_6059), Reflex::Literal("front"), method_6091, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_6057), Reflex::Literal("back"), method_6092, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_6059), Reflex::Literal("back"), method_6093, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_6059), Reflex::Literal("push_front"), method_6094, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662), Reflex::Literal("pop_front"), method_6095, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_6059), Reflex::Literal("push_back"), method_6096, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662), Reflex::Literal("pop_back"), method_6097, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_2481, type_2481, type_6059), Reflex::Literal("insert"), method_6098, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_2481, type_1275, type_6059), Reflex::Literal("insert"), method_6099, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_2481, type_2481), Reflex::Literal("erase"), method_6100, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_2481, type_2481, type_2481), Reflex::Literal("erase"), method_6101, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_13973), Reflex::Literal("swap"), method_6102, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662), Reflex::Literal("clear"), method_6103, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_2481, type_13973), Reflex::Literal("splice"), method_6104, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_2481, type_13973, type_2481), Reflex::Literal("splice"), method_6105, 0, "__position;__x;__i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_2481, type_13973, type_2481, type_2481), Reflex::Literal("splice"), method_6106, 0, "__position;__x;__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_6059), Reflex::Literal("remove"), method_6107, 0, "__value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662), Reflex::Literal("unique"), method_6108, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_13973), Reflex::Literal("merge"), method_6109, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662), Reflex::Literal("reverse"), method_6110, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662), Reflex::Literal("sort"), method_6111, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class allocator<ac_noc::addressMap> -------------------------------
static  void operator_8664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<ac_noc::addressMap>*)o)->operator=)(*(const ::std::allocator<ac_noc::addressMap>*)arg[0]);
  else   (((::std::allocator<ac_noc::addressMap>*)o)->operator=)(*(const ::std::allocator<ac_noc::addressMap>*)arg[0]);
}

static void constructor_8665( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<ac_noc::addressMap>();
  else ::new(mem) ::std::allocator<ac_noc::addressMap>();
}

static void constructor_8666( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<ac_noc::addressMap>(*(const ::std::allocator<ac_noc::addressMap>*)arg[0]);
  else ::new(mem) ::std::allocator<ac_noc::addressMap>(*(const ::std::allocator<ac_noc::addressMap>*)arg[0]);
}

static void destructor_8667(void*, void * o, const std::vector<void*>&, void *) {
  (((::std::allocator<ac_noc::addressMap>*)o)->::std::allocator<ac_noc::addressMap>::~allocator)();
}
static void method_newdel_2172( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<ac_noc::addressMap> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<ac_noc::addressMap> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<ac_noc::addressMap> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<ac_noc::addressMap> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<ac_noc::addressMap> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(dictionary, Reflex::Literal("__gnu_cxx::new_allocator<ac_noc::addressMap>")), ::Reflex::BaseOffset< ::std::allocator<ac_noc::addressMap>,::__gnu_cxx::new_allocator<ac_noc::addressMap> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<ac_noc::addressMap> -------------------------------
void __std__allocator_ac_noc__addressMap__db_datamem(Reflex::Class*);
void __std__allocator_ac_noc__addressMap__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_ac_noc__addressMap__datamem_bld(&__std__allocator_ac_noc__addressMap__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_ac_noc__addressMap__funcmem_bld(&__std__allocator_ac_noc__addressMap__db_funcmem);
void __std__allocator_ac_noc__addressMap__dict() {
  ::Reflex::ClassBuilder(dictionary, Reflex::Literal("std::allocator<ac_noc::addressMap>"), typeid(::std::allocator<ac_noc::addressMap>), sizeof(::std::allocator<ac_noc::addressMap>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3450, ::Reflex::BaseOffset< ::std::allocator<ac_noc::addressMap>, ::__gnu_cxx::new_allocator<ac_noc::addressMap> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1275, Reflex::Literal("std::allocator<ac_noc::addressMap>::size_type"))
  .AddTypedef(type_1017, Reflex::Literal("std::allocator<ac_noc::addressMap>::difference_type"))
  .AddTypedef(type_6053, Reflex::Literal("std::allocator<ac_noc::addressMap>::pointer"))
  .AddTypedef(type_6055, Reflex::Literal("std::allocator<ac_noc::addressMap>::const_pointer"))
  .AddTypedef(type_6057, Reflex::Literal("std::allocator<ac_noc::addressMap>::reference"))
  .AddTypedef(type_6059, Reflex::Literal("std::allocator<ac_noc::addressMap>::const_reference"))
  .AddTypedef(type_3598, Reflex::Literal("std::allocator<ac_noc::addressMap>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_14341, type_13971), Reflex::Literal("operator="), operator_8664, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("allocator"), constructor_8665, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void, type_13971), Reflex::Literal("allocator"), constructor_8666, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("~allocator"), destructor_8667, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2172, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<ac_noc::addressMap> -------------------
void __std__allocator_ac_noc__addressMap__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<ac_noc::addressMap> -------------------
void __std__allocator_ac_noc__addressMap__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<ac_noc::addressMap> -------------------------------
static void destructor_8931(void*, void * o, const std::vector<void*>&, void *) {
  (((::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>*)o)->::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>::~rebind)();
}
static  void operator_8932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>*)o)->operator=)(*(const ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>*)arg[0]);
  else   (((::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>*)o)->operator=)(*(const ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>*)arg[0]);
}

static void constructor_8933( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>(*(const ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>*)arg[0]);
  else ::new(mem) ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>(*(const ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>*)arg[0]);
}

static void constructor_8934( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>();
  else ::new(mem) ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>();
}

static void method_newdel_2197( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<ac_noc::addressMap> -------------------------------
void __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap__db_datamem(Reflex::Class*);
void __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap__datamem_bld(&__std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap__funcmem_bld(&__std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap__db_funcmem);
void __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap__dict() {
  ::Reflex::ClassBuilder(dictionary, Reflex::Literal("std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>"), typeid(::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>), sizeof(::std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2172, Reflex::Literal("std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("~rebind"), destructor_8931, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_14367, type_14368), Reflex::Literal("operator="), operator_8932, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void, type_14368), Reflex::Literal("rebind"), constructor_8933, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("rebind"), constructor_8934, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2197, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<ac_noc::addressMap> -------------------
void __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<ac_noc::addressMap> -------------------
void __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class new_allocator<ac_noc::addressMap> -------------------------------
static  void operator_12541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<ac_noc::addressMap>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<ac_noc::addressMap>*)arg[0]);
}

static void constructor_12542( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<ac_noc::addressMap>();
  else ::new(mem) ::__gnu_cxx::new_allocator<ac_noc::addressMap>();
}

static void constructor_12543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<ac_noc::addressMap>(*(const ::__gnu_cxx::new_allocator<ac_noc::addressMap>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<ac_noc::addressMap>(*(const ::__gnu_cxx::new_allocator<ac_noc::addressMap>*)arg[0]);
}

static void destructor_12544(void*, void * o, const std::vector<void*>&, void *) {
  (((::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->::__gnu_cxx::new_allocator<ac_noc::addressMap>::~new_allocator)();
}
static  void method_12545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->address)(*(::ac_noc::addressMap*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->address)(*(::ac_noc::addressMap*)arg[0]);
}

static  void method_12546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->address)(*(const ::ac_noc::addressMap*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->address)(*(const ::ac_noc::addressMap*)arg[0]);
}

static  void method_12547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->allocate)(*(::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->allocate)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->allocate)(*(::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->allocate)(*(::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_12548( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->deallocate)((::ac_noc::addressMap*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_12549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->max_size)();
}

static  void method_12550( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->construct)((::ac_noc::addressMap*)arg[0],
    *(const ::ac_noc::addressMap*)arg[1]);
}

static  void method_12551( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<ac_noc::addressMap>*)o)->destroy)((::ac_noc::addressMap*)arg[0]);
}

static void method_newdel_3450( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<ac_noc::addressMap> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<ac_noc::addressMap> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<ac_noc::addressMap> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<ac_noc::addressMap> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<ac_noc::addressMap> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<ac_noc::addressMap> -------------------------------
void ____gnu_cxx__new_allocator_ac_noc__addressMap__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_ac_noc__addressMap__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_ac_noc__addressMap__datamem_bld(&____gnu_cxx__new_allocator_ac_noc__addressMap__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_ac_noc__addressMap__funcmem_bld(&____gnu_cxx__new_allocator_ac_noc__addressMap__db_funcmem);
void ____gnu_cxx__new_allocator_ac_noc__addressMap__dict() {
  ::Reflex::ClassBuilder(dictionary, Reflex::Literal("__gnu_cxx::new_allocator<ac_noc::addressMap>"), typeid(::__gnu_cxx::new_allocator<ac_noc::addressMap>), sizeof(::__gnu_cxx::new_allocator<ac_noc::addressMap>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1275, Reflex::Literal("__gnu_cxx::new_allocator<ac_noc::addressMap>::size_type"))
  .AddTypedef(type_1017, Reflex::Literal("__gnu_cxx::new_allocator<ac_noc::addressMap>::difference_type"))
  .AddTypedef(type_6053, Reflex::Literal("__gnu_cxx::new_allocator<ac_noc::addressMap>::pointer"))
  .AddTypedef(type_6055, Reflex::Literal("__gnu_cxx::new_allocator<ac_noc::addressMap>::const_pointer"))
  .AddTypedef(type_6057, Reflex::Literal("__gnu_cxx::new_allocator<ac_noc::addressMap>::reference"))
  .AddTypedef(type_6059, Reflex::Literal("__gnu_cxx::new_allocator<ac_noc::addressMap>::const_reference"))
  .AddTypedef(type_3598, Reflex::Literal("__gnu_cxx::new_allocator<ac_noc::addressMap>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_15068, type_15069), Reflex::Literal("operator="), operator_12541, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("new_allocator"), constructor_12542, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void, type_15069), Reflex::Literal("new_allocator"), constructor_12543, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_void), Reflex::Literal("~new_allocator"), destructor_12544, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3450, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_ac_noc__addressMap__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<ac_noc::addressMap> -------------------
void ____gnu_cxx__new_allocator_ac_noc__addressMap__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<ac_noc::addressMap> -------------------
void ____gnu_cxx__new_allocator_ac_noc__addressMap__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_6053, type_6057), Reflex::Literal("address"), method_12545, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_6055, type_6059), Reflex::Literal("address"), method_12546, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_6053, type_1275, type_2563), Reflex::Literal("allocate"), method_12547, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_6053, type_1275), Reflex::Literal("deallocate"), method_12548, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_1275), Reflex::Literal("max_size"), method_12549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_6053, type_6059), Reflex::Literal("construct"), method_12550, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(dictionary, type_662, type_6053), Reflex::Literal("destroy"), method_12551, 0, "__p", ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __ac_noc_dict(); 
      __ac_noc__addressMap_dict(); 
      __std__list_ac_noc__addressMap__dict(); 
      __std__allocator_ac_noc__addressMap__dict(); 
      __std__allocator_ac_noc__addressMap___rebind_ac_noc__addressMap__dict(); 
      ____gnu_cxx__new_allocator_ac_noc__addressMap__dict(); 
    }
    ~Dictionaries() {
      type_507.Unload(); // class ac_noc 
      type_3598.Unload(); // class ac_noc::addressMap 
      type_1994.Unload(); // class std::list<ac_noc::addressMap> 
      type_2172.Unload(); // class std::allocator<ac_noc::addressMap> 
      type_2197.Unload(); // class std::allocator<ac_noc::addressMap>::rebind<ac_noc::addressMap> 
      type_3450.Unload(); // class __gnu_cxx::new_allocator<ac_noc::addressMap> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
